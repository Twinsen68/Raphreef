substitutions:  
  # Définit les variables substituables utilisées dans ce fichier.

  # Pins des capteurs optiques
  opticalLowPin: "33"  # GPIO pour le capteur optique bas
  opticalHighPin: "32"  # GPIO pour le capteur optique haut

  # Fréquence de mise à jour
  update_water: "60s"  # Intervalle de mise à jour des capteurs optiques

  # Capteur de débit
  flowSensorPin: "26"  # GPIO pour le capteur de débit
  pulses_per_litre: "450"  # Nombre d'impulsions correspondant à un litre
  update_interval: "10s"  # Intervalle de mise à jour des données de débit

esphome:
  # Configuration ESPHome
  on_boot: 
    priority: 200  # Priorité de démarrage
    then:
      - component.update: water_level  # Met à jour l'état du niveau d'eau au démarrage

switch:
  # Switch pour contrôler l'électrovanne
  - platform: output
    name: "Électrovanne"
    output: relais_valve
    id: electrovanne
    icon: mdi:valve

  - platform: template
    name: "Contrôle manuel de l'électrovanne"  # Nom visible dans Home Assistant
    id: manual_valve_control  # Identifiant unique pour le contrôle manuel
    optimistic: true  # Permet d'assurer la synchronisation de l'état dans Home Assistant
    turn_on_action:
      - switch.turn_on: electrovanne  # Ouvre la vanne
      - lambda: |-
          ESP_LOGI("manual_valve", "Électrovanne ouverte manuellement.");
    turn_off_action:
      - switch.turn_off: electrovanne  # Ferme la vanne
      - lambda: |-
          ESP_LOGI("manual_valve", "Électrovanne fermée manuellement.");

output:
  - platform: gpio
    pin: 25  # GPIO utilisé pour activer/désactiver l'électrovanne
    id: relais_valve

binary_sensor:
  # Définition des capteurs binaires

  # Capteur optique bas
  - platform: gpio
    id: os_low  # Identifiant unique pour le capteur bas
    pin: 
      number: ${opticalLowPin}  # GPIO spécifié dans les substitutions
      inverted: true  # Inversion de la logique du signal (haut = actif)
      mode:
        input: true
        pullup: true  # Active le pull-up interne pour une meilleure stabilité
    name: "Capteur niveau : Bas"  # Nom visible dans l'interface utilisateur
    filters:
      - delayed_on_off: 30ms  # Anti-rebond pour éviter les faux positifs
    on_state:
      then:
        # Met à jour l'état global du niveau d'eau
        - component.update: water_level  
        # Active ou désactive l'électrovanne selon l'état du capteur
        - if:
            condition:
              binary_sensor.is_off: os_low  # Si le niveau est trop bas
            then:
              - switch.turn_on: electrovanne  # Active l'électrovanne
        - if:
            condition:
              binary_sensor.is_on: os_low  # Si le niveau est corrigé
            then:
              - switch.turn_off: electrovanne  # Désactive l'électrovanne

  # Capteur optique haut
  - platform: gpio
    id: os_high  # Identifiant unique pour le capteur haut
    pin: 
      number: ${opticalHighPin}  # GPIO spécifié dans les substitutions
      inverted: true
      mode:
        input: true
        pullup: true
    name: "Capteur niveau : Haut"
    filters:
      - delayed_on_off: 30ms
    on_state:
      then:
        - component.update: water_level  # Met à jour l'état global du niveau d'eau

  # Anomalie : Volume excessif ajouté
  - platform: template
    name: "Anomalie : Volume excessif"  # Déclenche une alerte si plus de 10L sont ajoutés
    id: volume_anomaly
    lambda: |-
      static float session_volume = 0;  // Volume ajouté durant une session
      if (id(electrovanne).state) {
        session_volume += (id(flow_pulses).state / ${pulses_per_litre});  // Calcul du volume ajouté
        if (session_volume > 10.0) {  // Si le volume dépasse 10L
          if (id(auto_close_enabled).state) {  // Si l'auto-fermeture est activée
            id(electrovanne).turn_off();  // Ferme automatiquement l'électrovanne
          }
          return true;  // Retourne une anomalie
        }
      } else {
        session_volume = 0;  // Réinitialise le volume si la vanne est fermée
      }
      return false;  // Pas d'anomalie
    device_class: problem  # Classifié comme un problème dans Home Assistant

  # Anomalie : Vanne ouverte sans débit
  - platform: template
    name: "Anomalie : Vanne ouverte sans débit"  # Alerte si la vanne est ouverte mais qu'aucun débit n'est détecté
    id: no_flow_anomaly
    lambda: |-
      static unsigned long anomaly_start = 0;  // Temps de début de l'anomalie
      if (id(electrovanne).state && (id(flow_pulses).state == 0)) {
        if (anomaly_start == 0) {
          anomaly_start = millis();  // Initialisation du compteur
        }
        if ((millis() - anomaly_start) > 10000) {  // Tolérance de 10 secondes
          return true;  // Déclenche une anomalie
        }
      } else {
        anomaly_start = 0;  // Réinitialise si débit détecté ou vanne fermée
      }
      return false;  // Pas d'anomalie
    device_class: problem  # Classifié comme un problème

  # Anomalie : Débit détecté avec vanne fermée
  - platform: template
    name: "Anomalie : Débit avec vanne fermée"  # Alerte si un débit est détecté alors que la vanne est fermée
    id: flow_with_closed_valve
    lambda: |-
      if (!id(electrovanne).state && (id(flow_pulses).state > 0)) {
        return true;  // Déclenche une anomalie
      }
      return false;  // Pas d'anomalie
    device_class: problem  # Classifié comme un problème


sensor:
  # Définition des capteurs analogiques ou numériques

  # Mesure des impulsions du capteur de débit
  - platform: pulse_counter
    pin: ${flowSensorPin}  # GPIO pour le capteur de débit
    name: "Impulsions du capteur de débit"
    id: flow_pulses  # Identifiant unique
    update_interval: ${update_interval}  # Fréquence de mise à jour
    unit_of_measurement: "pulses"  # Unité affichée
    filters:
      - multiply: 1.0  # Applique un multiplicateur (aucune transformation ici)

  # Calcul du volume d'eau ajouté (en litres)
  - platform: template
    name: "Volume d'eau ajouté"
    id: volume_added  # Identifiant unique
    unit_of_measurement: "L"
    icon: mdi:water  # Icône utilisée
    update_interval: ${update_interval}
    lambda: |-
      return (id(flow_pulses).state / ${pulses_per_litre});  # Convertit impulsions en litres

  # Calcul du volume ajouté par jour
  - platform: integration
    name: "Volume ajouté - Jour"
    sensor: volume_added  # Source des données
    unit_of_measurement: "L"
    icon: mdi:calendar  # Icône pour une vue journalière
    time_unit: d  # Accumule les valeurs sur une base quotidienne

  # Calcul manuel du volume ajouté par semaine
  - platform: template
    name: "Volume ajouté - Semaine"
    id: volume_week
    unit_of_measurement: "L"
    icon: mdi:calendar-week
    lambda: |-
      static float weekly_volume = 0;  # Variable statique pour stocker les données
      weekly_volume += id(volume_added).state;  # Incrémente le volume hebdomadaire
      return weekly_volume;  # Retourne le cumul

  # Volume total ajouté depuis le démarrage
  - platform: template
    name: "Volume ajouté - Total"
    id: volume_total
    unit_of_measurement: "L"
    icon: mdi:water-plus
    lambda: |-
      static float total_volume = 0;  # Variable pour stocker le total
      total_volume += id(volume_added).state;  # Ajoute le volume à chaque mise à jour
      return total_volume;  # Retourne le total

text_sensor:
  # État global du niveau d'eau
  - platform: template
    icon: mdi:waves-arrow-up  # Icône pour illustrer le niveau d'eau
    name: "Niveau d'eau"
    id: water_level
    update_interval: "${update_water}"
    lambda: |-
      if(id(os_high).state == true && id(os_low).state == true) {
        return {"Trop haut"};  # Les deux capteurs actifs
      }
      if(id(os_high).state == false && id(os_low).state == false) {
        return {"Trop bas"};  # Aucun capteur actif
      }
      if(id(os_high).state == false && id(os_low).state == true) {
        return {"Optimal"};  # Niveau correct
      } else {
        return {"Inconnu ou erreur"};  # État indéterminé

  - platform: template
    name: "État de l'électrovanne"
    lambda: |-
      if (id(electrovanne).state) {
        return {"Active"};  // Si la vanne est ouverte
      } else {
        return {"Inactive"};  // Si la vanne est fermée
      }
    icon: mdi:valve

  - platform: template
    name: "Mode de contrôle de l'électrovanne"  # Indique le mode actif
    lambda: |-
      if (id(auto_close_enabled).state) {
        return {"Automatique"};  // Mode automatique activé
      } else {
        return {"Manuel"};  // Mode manuel activé
      }
    icon: mdi:toggle-switch

button:
  # Réinitialise tous les volumes (journaliers, hebdomadaires, totaux)
  - platform: template
    name: "Réinitialiser tous les volumes"
    id: reset_all_volumes
    on_press:
      then:
        - lambda: |-
            id(flow_pulses).publish_state(0);  # Réinitialise les impulsions
            id(volume_total).publish_state(0);  # Réinitialise le volume total
            id(volume_week).publish_state(0);  # Réinitialise le volume hebdomadaire
            ESP_LOGI("reset", "Tous les volumes ont été réinitialisés !");

  # Active ou désactive la fermeture automatique de l'électrovanne
  - platform: template
    name: "Activer/Désactiver Auto-Fermeture"  # Bouton pour gérer l'option
    id: auto_close_toggle
    on_press:
      then:
        - lambda: |-
            id(auto_close_enabled).publish_state(!id(auto_close_enabled).state);  // Change l'état
            ESP_LOGI("auto_close", "État changé : %s", id(auto_close_enabled).state ? "Activé" : "Désactivé");

globals:
  # Variable pour gérer l'état de l'auto-fermeture de l'électrovanne
  - id: auto_close_enabled  # Identifiant unique de la variable
    type: bool  # Type de la variable (booléen : vrai ou faux)
    restore_value: true  # La valeur est sauvegardée et restaurée après un redémarrage
    initial_value: "true"  # La variable est initialisée à "true" par défaut

  - id: manual_override_timeout  # Identifiant unique pour la variable.
    type: unsigned long  # Type de données : durée en millisecondes.
    restore_value: no  # Ne pas restaurer après redémarrage (pour éviter des incohérences).
    initial_value: "0"  # Initialise la variable à zéro.

select:
  - platform: template
    name: "Durée avant retour auto"  # Nom affiché dans Home Assistant.
    id: auto_reset_duration  # Identifiant utilisé dans le code ESPHome.
    optimistic: true  # Synchronisation sans retour d'état direct de l'appareil.
    options:
      - "10 minutes"  # Option pour 10 minutes.
      - "30 minutes"  # Option pour 30 minutes.
      - "1 heure"  # Option pour 1 heure.
      - "6 heures"  # Option pour 6 heures.
      - "1 jour"  # Option pour 1 jour.
      - "2 jours"  # Option pour 2 jours.
    initial_option: "30 minutes"  # Option par défaut.
    set_action:
      - logger.log:
          format: "Durée sélectionnée pour retour automatique : %s"  # Log de débogage.
          args: ["x.c_str()"]  # Affiche la valeur sélectionnée.

interval:
  - interval: 1s  # Vérification de l'état toutes les secondes.
    then:
      - lambda: |-
          static unsigned long override_start_time = 0;  // Heure de début de la désactivation manuelle.
          static unsigned long duration = 0;  // Durée en millisecondes pour l'override.

          // 1. Convertir la durée sélectionnée en millisecondes.
          if (id(auto_reset_duration).state == "10 minutes") {
            duration = 600000;  // 10 minutes.
          } else if (id(auto_reset_duration).state == "30 minutes") {
            duration = 1800000;  // 30 minutes.
          } else if (id(auto_reset_duration).state == "1 heure") {
            duration = 3600000;  // 1 heure.
          } else if (id(auto_reset_duration).state == "6 heures") {
            duration = 21600000;  // 6 heures.
          } else if (id(auto_reset_duration).state == "1 jour") {
            duration = 86400000;  // 1 jour.
          } else if (id(auto_reset_duration).state == "2 jours") {
            duration = 172800000;  // 2 jours.

          // 2. Si l'électrovanne est désactivée manuellement, démarrez le chronomètre.
          if (!id(electrovanne).state && id(manual_override_timeout) == 0) {
            override_start_time = millis();  // Enregistre l'heure actuelle.
            id(manual_override_timeout) = duration;  // Définit la durée de l'override.
          }

          // 3. Vérifiez si la durée d'override est écoulée.
          if (id(manual_override_timeout) > 0 &&
              (millis() - override_start_time) >= id(manual_override_timeout)) {
            id(manual_override_timeout) = 0;  // Réinitialise la variable.
            id(auto_close_enabled).publish_state(true);  // Réactive le mode automatique.
            ESP_LOGI("auto_reset", "Retour automatique en mode automatique.");
          }
